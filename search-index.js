var searchIndex = {};
searchIndex["tetrs"] = {"doc":"The tetrs library provides a number of low-level tasks related to movement\nof blocks. The code aims to be correct and provide easy extension for new\ninput.","items":[[4,"Rotation","tetrs","Represents all rotation statuses a block can be. This is used both as\na rotation state, and to indicate how much relative movement shoud be\napplied for various functions.",null,null],[13,"R0","","",0,null],[13,"R90","","",0,null],[13,"R180","","",0,null],[13,"R270","","",0,null],[4,"Direction","","Specifies a particular direction of movement.",null,null],[13,"None","","",1,null],[13,"Left","","",1,null],[13,"Right","","",1,null],[13,"Up","","",1,null],[13,"Down","","",1,null],[0,"field","","A generic field for use with a game.",null,null],[3,"Field","tetrs::field","Implements a field state with specified dimensions and game data.",null,null],[12,"width","","The width of the field.",2,null],[12,"height","","The height of the field.",2,null],[12,"hidden","","The height of the hidden region of the field.",2,null],[12,"spawn","","The initial spawn of all blocks.",2,null],[12,"data","","The current field state.",2,null],[11,"fmt","","",2,{"inputs":[{"name":"field"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"field"}],"output":{"name":"field"}}],[11,"hash","","",2,null],[11,"new","","Construct a new field object.",2,{"inputs":[],"output":{"name":"field"}}],[11,"with_options","","Construct a new field object with the specified options.",2,null],[11,"clear_lines","","Clear lines from the field and return the number cleared.",2,{"inputs":[{"name":"field"}],"output":{"name":"usize"}}],[11,"freeze","","Freeze a block into place on the field. This takes ownership of the\nblock to ensure it cannot be used again.",2,{"inputs":[{"name":"field"},{"name":"block"}],"output":null}],[11,"at","","Return the value at the specified field location",2,null],[11,"set","","Return if the value at the specified location is empty or not.",2,null],[0,"block","tetrs","A block represents a single tetrimino and is always tied to a specific\nfield instance.",null,null],[3,"Block","tetrs::block","A block.",null,null],[12,"x","","X-coordinate of the piece",3,null],[12,"y","","Y-coordinate of the piece",3,null],[12,"id","","Type of the block",3,null],[12,"r","","Rotation state of the block",3,null],[12,"data","","Block offset data",3,null],[4,"Type","","The type of a specific block.",null,null],[13,"I","","",4,null],[13,"T","","",4,null],[13,"L","","",4,null],[13,"J","","",4,null],[13,"S","","",4,null],[13,"Z","","",4,null],[13,"O","","",4,null],[13,"None","","",4,null],[11,"eq","","",4,{"inputs":[{"name":"type"},{"name":"type"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"type"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"type"}],"output":{"name":"type"}}],[11,"hash","","",4,null],[11,"to_usize","","",4,{"inputs":[{"name":"type"}],"output":{"name":"usize"}}],[11,"from_usize","","",4,{"inputs":[{"name":"usize"}],"output":{"name":"type"}}],[11,"variants","","Returns all known types",4,{"inputs":[],"output":{"name":"vec"}}],[11,"fmt","","",3,{"inputs":[{"name":"block"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"block"}],"output":{"name":"block"}}],[11,"hash","","",3,null],[11,"new","","Construct a new block from the specified input parameters.",3,{"inputs":[{"name":"type"},{"name":"rotation"}],"output":{"name":"block"}}],[11,"new_at","","Construct a block at the specific location on the field.",3,null],[11,"reset","","Consumes the current block returning a new block that has been\n`reset` (respawned).",3,{"inputs":[{"name":"block"}],"output":{"name":"block"}}],[11,"leading","","Returns a tuple with the minimum x, y values of the current block.",3,null],[11,"trailing","","Returns a tuple with the maximum x, y values of the current block",3,null],[11,"collision","","Checks if the current block collides with anything on field.",3,{"inputs":[{"name":"block"},{"name":"field"}],"output":{"name":"bool"}}],[11,"shift","","Shift the block one place by the specified direction.",3,{"inputs":[{"name":"block"},{"name":"field"},{"name":"direction"}],"output":{"name":"bool"}}],[11,"shift_extend","","Repeatedly shift a block as far as we can until a collision occurs.",3,{"inputs":[{"name":"block"},{"name":"field"},{"name":"direction"}],"output":null}],[11,"rotate_with_offset","","Rotate the block by the specified amount and apply an offset.\nThis is a helper function for calculating wallkick values easily.",3,null],[11,"rotate","","Rotate the block by the specified amount.",3,{"inputs":[{"name":"block"},{"name":"field"},{"name":"rotation"}],"output":{"name":"bool"}}],[11,"at","","Check if the block occupies the specified offset.",3,null],[11,"ghost","","Return a new block that is this blocks ghost.",3,{"inputs":[{"name":"block"},{"name":"field"}],"output":{"name":"block"}}],[11,"data","","Return the block data for the specified type.",3,null],[11,"offset","","Return the block offsets for the specified type.",3,null],[11,"offset_to_first","","Return the offset to the first piece. This is slightly different\nfrom `offset` which itself returns the offsets of empty rows/cols.",3,null],[0,"controller","tetrs","An abstract controller for specifying actions.",null,null],[3,"Controller","tetrs::controller","A controller stores the internal state as a series of known actions.",null,null],[4,"Action","","Abstract actions which are understood by the controller.",null,null],[13,"MoveLeft","","",5,null],[13,"MoveRight","","",5,null],[13,"MoveDown","","",5,null],[13,"HardDrop","","",5,null],[13,"RotateLeft","","",5,null],[13,"RotateRight","","",5,null],[13,"Hold","","",5,null],[13,"Quit","","",5,null],[11,"fmt","","",5,{"inputs":[{"name":"action"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"action"}],"output":{"name":"action"}}],[11,"hash","","",5,null],[11,"to_usize","","",5,{"inputs":[{"name":"action"}],"output":{"name":"usize"}}],[11,"from_usize","","",5,{"inputs":[{"name":"usize"}],"output":{"name":"action"}}],[11,"new","","Return a new controller instance.",6,{"inputs":[],"output":{"name":"controller"}}],[11,"active","","Query if an action is currently active.",6,{"inputs":[{"name":"controller"},{"name":"action"}],"output":{"name":"bool"}}],[11,"time","","Query how long an action has been active for.",6,{"inputs":[{"name":"controller"},{"name":"action"}],"output":{"name":"usize"}}],[11,"activate","","Activate the specified action.",6,{"inputs":[{"name":"controller"},{"name":"action"}],"output":null}],[11,"deactivate","","Deactivate the specified action.",6,{"inputs":[{"name":"controller"},{"name":"action"}],"output":null}],[11,"update","","Update all active actions and increment their timers.",6,{"inputs":[{"name":"controller"}],"output":null}],[0,"wallkick","tetrs","Implements a wallkick test",null,null],[0,"srs","tetrs::wallkick","Implements the wallkicks for the SRS rotation system.",null,null],[8,"WallkickTest","","Trait which specifies what wallkick tests must implement. Every wallkick\ntest must implement an iterator with offsets of type (i32, i32).",null,null],[10,"test","","Returns a set of wallkick tests for the specified block and rotation",7,null],[0,"randomizer","tetrs","Implements a randomizer.",null,null],[0,"bag_randomizer","tetrs::randomizer","Implements a 7-element bag randomizer.",null,null],[3,"BagRandomizer","tetrs::randomizer::bag_randomizer","A generic bag randomizer.",null,null],[11,"clone","","",8,{"inputs":[{"name":"bagrandomizer"}],"output":{"name":"bagrandomizer"}}],[11,"new","","Return a new BagRandomizer instance.",8,{"inputs":[],"output":{"name":"bagrandomizer"}}],[11,"preview","","",8,{"inputs":[{"name":"bagrandomizer"}],"output":{"name":"vec"}}],[11,"next","","",8,{"inputs":[{"name":"bagrandomizer"}],"output":{"name":"option"}}],[8,"Randomizer","tetrs::randomizer","This trait must be implemented by all randomizers. This is in effect an\niterator with the specified type.",null,null],[10,"preview","","Preview returns a list of upcoming blocks. This can be any length,\nincluding 0 length in the case of no previews.",9,{"inputs":[{"name":"randomizer"}],"output":{"name":"vec"}}],[0,"schema","tetrs","Methods for converting to and from a textual field representation.",null,null],[3,"Schema","tetrs::schema","A schema is a simple 2d textual representation of a field and a block.\nIt allows conversion from a string, and also from a `(&amp;Field, &amp;Block)` and\nbridges the gap between these two components.",null,null],[11,"fmt","","",10,{"inputs":[{"name":"schema"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"schema"}],"output":{"name":"schema"}}],[11,"from_state","","Construct a schema representation from an game primitives.",10,{"inputs":[{"name":"field"},{"name":"block"}],"output":{"name":"schema"}}],[11,"from_string","","Construct a schema representation from an input string.",10,{"inputs":[{"name":"str"}],"output":{"name":"schema"}}],[11,"to_state","","Constuct state objects from a given schema. This is slightly finicky\nand there are a few cases to consider.",10,null],[11,"to_string","","Construct a visual representation from a given schema.",10,{"inputs":[{"name":"schema"}],"output":{"name":"string"}}],[11,"fmt","","",10,{"inputs":[{"name":"schema"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"schema"},{"name":"self"}],"output":{"name":"bool"}}],[11,"eq","tetrs","",0,{"inputs":[{"name":"rotation"},{"name":"rotation"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"rotation"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"rotation"}],"output":{"name":"rotation"}}],[11,"hash","","",0,null],[11,"to_usize","","",0,{"inputs":[{"name":"rotation"}],"output":{"name":"usize"}}],[11,"from_usize","","",0,{"inputs":[{"name":"usize"}],"output":{"name":"rotation"}}],[11,"variants","","Returns all rotation variants",0,{"inputs":[],"output":{"name":"vec"}}],[11,"clockwise","","Returns the next clockwise rotation.",0,{"inputs":[{"name":"rotation"}],"output":{"name":"rotation"}}],[11,"anticlockwise","","Returns the next anticlockwise rotation.",0,{"inputs":[{"name":"rotation"}],"output":{"name":"rotation"}}],[11,"eq","","",1,{"inputs":[{"name":"direction"},{"name":"direction"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"direction"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"direction"}],"output":{"name":"direction"}}],[11,"hash","","",1,null],[11,"variants","","It is required to be able to iterate over enums in some places. These\nenums are simple CLike so it isn&#39;t too weird to think we would need to\ndo this, but it still provides some problems.",1,{"inputs":[],"output":{"name":"vec"}}]],"paths":[[4,"Rotation"],[4,"Direction"],[3,"Field"],[3,"Block"],[4,"Type"],[4,"Action"],[3,"Controller"],[8,"WallkickTest"],[3,"BagRandomizer"],[8,"Randomizer"],[3,"Schema"]]};
initSearch(searchIndex);
